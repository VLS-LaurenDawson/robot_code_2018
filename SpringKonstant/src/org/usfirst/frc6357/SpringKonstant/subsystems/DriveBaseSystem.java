// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc6357.SpringKonstant.subsystems;

import com.analog.adis16448.frc.ADIS16448_IMU;

import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class DriveBaseSystem extends Subsystem // MARK: BreakPoint
{
    private final PositionAndVelocityControlledDrivetrainSide leftSide;
    private final PositionAndVelocityControlledDrivetrainSide rightSide;
    private final ADIS16448_IMU myIMU;
    private final double Kp_angleChange = 0.1;

    private boolean isInVelocityMode;
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    public DriveBaseSystem(SpeedController baseFrontLeft, SpeedController baseFrontRight, 
    					   Encoder baseLeftEncoder, Encoder baseRightEncoder, ADIS16448_IMU inIMU)
    {
    	super();
        leftSide = new PositionAndVelocityControlledDrivetrainSide(baseFrontLeft, baseLeftEncoder);
        rightSide = new PositionAndVelocityControlledDrivetrainSide(baseFrontRight, baseRightEncoder);
        isInVelocityMode = true;
        myIMU = inIMU;
    }
    
    public void SetPositionMode()
    {
    	leftSide.SetPositionMode();
    	rightSide.SetPositionMode();
    	isInVelocityMode = false;
    }
    
    public void SetVelocityMode()
    {
    	leftSide.SetVelocityMode();
    	rightSide.SetVelocityMode();
    	isInVelocityMode = true;
    }
    
    public boolean IsInVelocityMode()
    {
    	return isInVelocityMode;
    }
    
    public void initDefaultCommand() 
    {
        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    public boolean setLeftMotorSpeedPercent(double percent)
    {
    	return leftSide.SetSpeedPercent(percent);
    }
    
    public boolean setRightMotorSpeedPercent(double percent)
    {
    	return rightSide.SetSpeedPercent(percent);
    }
    
    public boolean setLeftMotorSpeed(double speed)
    {
    	return leftSide.SetSpeedAbsolute(speed);
    }
    
    public boolean setRightMotorSpeed(double speed)
    {
    	return rightSide.SetSpeedAbsolute(speed);
    }
    
    public double getTurnDistance(double angle)								//Turns angle to the distance around the circle
    {
    	return (2 * Math.PI *11.125 /(12))*(angle/360.0);
    }
    
    public void rotateRobot(double angle)									//Assign speed to the motors to execute the turn
    {
    	leftSide.SetDistanceTarget(getTurnDistance(angle));
    	rightSide.SetDistanceTarget(-1 * getTurnDistance(angle));
    }
    
    public void AdjustAngle(double angle)									//Makes an adjustment in robot course in case of change in course
    {
    	double angleError = angle - myIMU.getAngleY();
    	
    }
    
    public void DriveStraight(double distance)								//Drives straight during autonomous
    {
    	leftSide.SetDistanceTarget(distance);
    	rightSide.SetDistanceTarget(distance);
    	
    }
        
    public void Update(){
    	// If we are in velocity mode, we don't update here
    	// But if we are not, then we are in position mode and need to correct for drift
    	if(!isInVelocityMode){
    		
    	}
    }
    
}

